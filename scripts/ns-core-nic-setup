#! /bin/bash

# Check for root user
if [ "$EUID" -ne 0 ]; then
    echo "This script must be run as root"
    exit 1
fi

NETRONOME_DIR=/opt/netronome
NETRONOME_BIN="$NETRONOME_DIR"/bin

udev_file=/etc/udev/rules.d/99-netronome-corenic.udev.rules
blacklist_file=/etc/modprobe.d/blacklist-netronome.conf
mod_file=/etc/modprobe.d/nfp.conf
dep_file=/etc/depmod.d/nfp.conf
fw_dir=/lib/firmware/netronome/
fw_dir_cnic=/lib/firmware/netronome/cnic
fw_file=/lib/firmware/netronome/nic_dpdk_default.nffw
log_file_dir=/opt/netronome/log
log_file=$log_file_dir/ns-core-nic.log
log_disable_file=$log_file_dir/ns-core-nic-log.disable

mkdir -p $log_file_dir

print_heading() {
    echo "======== $1 ========"
}

function log() {
    logger -si "ns-core-nic: $@"
    d=$(date)
    if [ ! -e "$log_disable_file" ]; then
        echo "$d | ns-core-nic: $@" >> $log_file
    fi
}

function write_head() {
    local out_file
    out_file=$1

    echo "# Copyright (C) 2012-2017 Netronome Systems, Inc. All rights reserved." > $out_file
    echo "# Netronome Core NIC udev rules to configure the names of the" >> $out_file
    echo "# netdev(s) created when using the Core NIC."   >> $out_file
    echo "# Netronome Core NIC uses the nfp (formerly nfp_net) driver." >> $out_file
    echo "" >> $out_file
}

function write_rule() {
    local out_file mac id
    out_file=$1
    mac=$2
    id=$3
    # TBD - ATTR{dev_id}=="0x0", ATTR{type}=="1"
    echo "SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"nfp\", ATTR{address}==\"$mac\", NAME=\"nfp_p$id\""  >> $out_file
    echo "" >> $out_file
}

function check_and_load_driver() {
    # after DKMS install the nfp driver is not automatically
    # loaded. If nfp is loaded it is a previous version that we
    # have to unload. And then load the version we just installed
    local nfp_net_drv_check ref_cnt dev_cpp

    ref_cnt=0
    if [ -f /sys/module/nfp ]; then
        ref_cnt=$(cat /sys/module/nfp/refcnt)
    fi

    if [ "$ref_cnt" != "0" ]; then
        log "Cannot unload nfp, ref count non-zero"
        dev_cpp=$(cat /sys/module/nfp/parameters/nfp_dev_cpp 2>/dev/null)
        if [ "${dev_cpp}" != "1" ]; then
            log "nfp loaded without CPP access"
            log "ERROR"
            return 1
        fi
    else
        if [ -f /sys/module/nfp ]; then
            log "nfp already loaded"
            log "Attempting to unload nfp driver"
            rmmod nfp
            if [ "$?" -ne 0 ]; then
                log "Unload of nfp driver failed"
                log "ERROR"
                return 1
            fi
        fi

        log "Attempting to load nfp driver (userspace access only)"
        modprobe nfp nfp_pf_netdev=0 nfp_dev_cpp=1
        if [ "$?" -ne 0 ]; then
            log "Auto load of nfp_net driver failed"
            log "nfp driver is not loaded."
            log "ERROR"
            return 1
        fi
    fi

    return 0
}

function clean_udev() {
    log "Removing udev file $udev_file..."
    rm -f "$udev_file"
}

function write_udev() {
    local ethm_mac mac_addr netdev_id
    if [ -e "$udev_file" ]; then
        clean_udev
    fi

    log "Writing udev header..."
    write_head "$udev_file"

    # If the kernel has the phys_port_name feature
    log "Obtaining hwinfo..."
    ethm_mac=$(printf "%d\n" 0x$($NETRONOME_BIN/nfp-hwinfo | awk -F'=' '/eth0.mac/ {print $2}' | tr -d ':') 2>/dev/null)
    if [ "$ethm_mac" -eq "0" ]; then
        log "Failed to obtain MAC addresses!"
        return 1
    fi

    log "Writing Rules..."
    for netdev_id in `seq 0 7`
    do
        mac_addr=$(printf "00%x\n" $((ethm_mac+$netdev_id)) | sed -e 's/.\{2\}/&:/g' -e 's/://6')
        write_rule "$udev_file" "$mac_addr" "$netdev_id"
    done

    return 0
}

function process_platform() {
    local hwinfo_amda hwinfo_mac_ct selected_fw fw_path
    hwinfo_amda=$($NETRONOME_BIN/nfp-hwinfo | grep "assembly.partno" | cut -d '=' -f 2)
    hwinfo_mac_ct=$($NETRONOME_BIN/nfp-hwinfo | grep -c "eth[0-7].mac")
    nfp_media=$($NETRONOME_BIN/nfp-media  | cut -d '=' -f 2)
    log "Detecting platform..."
    selected_fw=

    err=0

    if [ "$hwinfo_amda" == "AMDA0096-0001" ]; then
        # No breakout cables supported
        selected_fw=nic_${hwinfo_amda}_2x10.nffw
    elif [ "$hwinfo_amda" == "AMDA0081-0001" ]; then
        if [ "$hwinfo_mac_ct" == "1" ]; then
            selected_fw=nic_${hwinfo_amda}_1x40.nffw
        elif [ "$hwinfo_mac_ct" == "4" ]; then
            selected_fw=nic_${hwinfo_amda}_4x10.nffw
        else
            err=1
        fi
    elif [ "$hwinfo_amda" == "AMDA0097-0001" ]; then
        if [ "$hwinfo_mac_ct" == "2" ]; then
            selected_fw=nic_${hwinfo_amda}_2x40.nffw
        elif [ "$hwinfo_mac_ct" == "5" ]; then
            if ( [[ ${nfp_media} == *"4x10G"*"40G"* ]] ) ; then
		selected_fw=nic_${hwinfo_amda}_4x10_1x40.nffw
            else
                err=1
            fi
        elif [ "$hwinfo_mac_ct" == "8" ]; then
            selected_fw=nic_${hwinfo_amda}_8x10.nffw
        else
            err=1
        fi
    elif [ "$hwinfo_amda" == "AMDA0099-0001" ]; then
        if ( [[ ${nfp_media} == *"10G"*"10G"* ]] ) ; then
            selected_fw=nic_${hwinfo_amda}_2x10.nffw
        elif ( [[ ${nfp_media} == *"25G"*"25G"* ]] ) ; then
            selected_fw=nic_${hwinfo_amda}_2x25.nffw
        else
            err=1
        fi
    else
        err=1
    fi

    if [ $err -ne 0 ]; then
        log "NS Platform detection failed!"
        log "  Invalid AMDA, Port count or Media config"
        log "    AMDA  : $hwinfo_amda"
        log "    CT    : $hwinfo_mac_ct"
        log "    Media : $nfp_media"
        log "ERROR"
        return $err
    else
        if [ -a "$fw_dir_cnic/$selected_fw" ]; then
            rm -f "$fw_file"
            echo "boo"
            log "Creating firmware symlink..."
            ln -s "$fw_dir_cnic/$selected_fw" "$fw_file"
        else
            log "Firmware file $fw_dir_cnic/$selected_fw does not exist."
            log "ERROR"
            return 1
        fi
    fi

    return 0
}

function err47_check() {
    grep -wq quirk_nfp6000 /boot/System.map-"$(uname -r)"
    if [ $? -ne 0 ]; then
        log "ERR47 kernel patches not detected on this system"
        # TODO: instruct the user on how to apply them
        return 1
    fi
    return 0
}

function reload_nfp_net() {
    local nfp_net_drv_check ref_cnt

    ref_cnt=0
    if [ -f /sys/module/nfp ]; then
	ref_cnt=$(cat /sys/module/nfp/refcnt)
    fi

    if [ "$ref_cnt" != "0" ]; then
        return 0
    fi

    if [ -f /sys/module/nfp ]; then
        rmmod nfp
    fi

    modprobe nfp nfp_dev_cpp=1

    return $?
}

function blacklist_nfp() {
    log "Permitting auto-load of nfp..."
    # Overwrite file
    echo "# This file is used to select the NFP vs nfp kernel module" > $blacklist_file
    echo "#" >> $blacklist_file
    echo "# Permit autoloading of the the nfp.ko kernel module" >> $blacklist_file
    echo "blacklist nfp_uio" >> $blacklist_file

    echo "# default parameters for Netronome nfp module" > $mod_file
    if `$NETRONOME_BIN/nfp-hwinfo | grep "^assembly.model" | grep -v "starfighter">/dev/null 2>&1`; then
        echo "options nfp nfp_dev_cpp=1" >> $mod_file
    else
        echo "options nfp nfp_pf_netdev=0 nfp_dev_cpp=1" >> $mod_file
    fi

    # TODO: edit blacklist file to remove options added by nfp-bsp pkg

}

function clean_depmod() {
    log "Removing depmod file $dep_file..."
    if [ -e "$dep_file" -a -n "$dep_file" ]; then
        rm -f $dep_file
    fi
}

function override_intree_nfp() {
    log "Overriding intree nfp..."
    write_head "$dep_file"
    echo -e "override nfp * extra/netronome" >> $dep_file
    echo -e "override nfp * updates/dkms" >> $dep_file
    echo -e "override nfp * extra" >> $dep_file
    depmod -a
}

function check_file_status() {
    local udev_status modprobe_status fw_file_status

    udev_status=1
    if [ -f "$udev_file" ]; then
        udev_status=0
    fi

    modprobe_status=1
    if [ -f "$blacklist_file" ]; then
        modprobe_status=0
    fi

    fw_file_status=1
    if [ -f "$fw_dir" ]; then
        fw_file_status=0
    fi

    if [ $udev_status -eq 0 ] && [ $modprobe_status -eq 0 ] && [ $fw_file_status -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

function boot_nic() {

    process_platform

    return
}

function setup_nic() {
    # check err47
    err47_check || return
    # verify nfp is loaded
    check_and_load_driver || return
    # create symlink for PMD
    process_platform
    # select nfp over nfp_uio
    blacklist_nfp
    # clean depmod file
    clean_depmod
    # override the intree nfp
    override_intree_nfp
    # reload nfp
    reload_nfp_net || return
}

check_minimum_version() {
    current_version=$1
    required_version=$2
    if [ "$(echo "$current_version" | grep -Eo "^[0-9a-fA-F]{2}")" = "$(echo "$required_version" | grep -Eo "^[0-9a-fA-F]{2}")" ] && \
                [ "$(printf "%d\n" 0x$current_version)" -ge "$(printf "%d\n" 0x$required_version)" ]; then
        return 0
    fi
    return 1
}

function check_flash() {
    # Minimum required versions
    local req_primary="020014"
    local req_secondary="020014"
    local req_nsp="02004e"

    local versions
    # Is BSP available?
    if [ -e "${NETRONOME_BIN}/nfp-hwinfo" ]; then
        versions=$(${NETRONOME_BIN}/nfp-hwinfo | grep bsp.version= | sed -r 's/.*=(.*)$/\1/')
    else
        versions=$(dmesg | grep 'nfp.*BSP'| sed -r 's/.*BSP:\s?(.*)$/\1/' | tail -1)
    fi

    local primary=$(echo "${versions}" | sed -r 's/([0-9A-Za-z]+)\.([0-9A-Za-z]+)\.([0-9A-Za-z]+).*/\1/')
    local secondary=$(echo "${versions}" | sed -r 's/([0-9A-Za-z]+)\.([0-9A-Za-z]+)\.([0-9A-Za-z]+).*/\2/')
    local nsp=$(echo "${versions}" | sed -r 's/([0-9A-Za-z]+)\.([0-9A-Za-z]+)\.([0-9A-Za-z]+).*/\3/')

    # To detemine whether the NSP version is up to date, the reported NSP version
    # must have a corresponding host file (if the BSP is installed). This will only
    # be true if the NSP is up to date.
    # If the BSP is not available, assume the NSP is up to date.
    nsp_already_updated=0
    if [ -e "/opt/netronome/flash/nfp-nspd.bin" ]; then
        [ -e "/opt/netronome/flash/nfp-nspd-$nsp.bin" ] || nsp_already_updated=1
    fi

    set -e
    if check_minimum_version $primary $req_primary && check_minimum_version $secondary $req_secondary && \
            check_minimum_version $nsp $req_nsp && [ "$nsp_already_updated" -eq "0" ]; then
        echo "NFP already has desired ARM flash image"
        exit 0
    fi

    # If we haven't forced a reflash and the minimum requirements of the primary/secondary
    # versions have been met, we only have to download the NSP binary.
    local ret=1
    if check_minimum_version $primary $req_primary && check_minimum_version $secondary $req_secondary; then
        print_heading "NFP requires an updated NSP only"
        echo -e "\t # This command needs to be executed again after reboot."
        echo -e "\t$NETRONOME_BIN/nfp-nsp -L /opt/netronome/flash/nfp-nspd.bin"
        echo -e "\n\t # To make the change persistent, reflash the card with:"
        ret=0
    else
        print_heading "NFP requires a new ARM flash image"
    fi
    echo -e "\t$NETRONOME_BIN/nfp-flash --preserve-media-overrides -w /opt/netronome/flash/flash-nic.bin"
    echo -e "\t$NETRONOME_BIN/nfp-one"
    echo -e "\treboot"
    print_heading
    exit $ret
}

function usage() {
    echo "CLI: $1 (<no param> | boot | clean | force | check-flash | help | log-enable | log-disable)"
    echo "This utility is used to setup the CoreNIC configuration"
    echo "  for ns-agilio-corenic usage"
    echo ""
    echo "This utility will update udev rules, set up driver blacklists,"
    echo "  place the proper CoreNIC firmware in"
    echo "  /lib/firmware/netronome/nfp6000_net.nffw"
    echo ""
    echo "Usage examples:"
    echo "EX: $0"
    echo "  Will configure CoreNIC for the nfp nic detected on the system"
    echo "EX: $0 clean"
    echo "  Will clean all CoreNIC configuration from the system"
    echo "EX: $0 force"
    echo "  Will force the configuration of CoreNIC on the system"
    echo ""
    echo "EX: $0 log-disable"
    echo "  Disables logging to /opt/netronome/log"
    echo "EX: $0 log-enable"
    echo "  Enables logging to /opt/netronome/log"
    echo ""
    exit 0
}

case "$1" in
    "boot")
        boot_nic || exit
        ;;
    "clean")
        # remove depmod file
        clean_depmod
        ;;
    "force")
        setup_nic || exit
        ;;
    "check-flash")
        check_flash
        ;;
    "-h")
        usage $0
        ;;
    "help")
        usage $0
        ;;
    "log-enable")
        if [ -e "$log_disable_file" ]; then
            rm "$log_disable_file"
        fi
        log "Logging enabled"
        ;;
    "log-disable")
        log "Logging disabled"
        echo "# File used to indicate logging is disable to /opt/netronome/log" > "$log_disable_file"
        ;;
    *)
        check_file_status
        if [ $? -ne 0 ]; then
            setup_nic || exit
        else
            log "CoreNIC files already exist."
            log "Re-run with '$0 force' to force a CoreNIC new setup"
        fi
        ;;
esac

log "Done!"
exit 0
