diff --git a/docs/nfd_user_cfg.txt b/docs/nfd_user_cfg.txt
index ca31be32..330a5cec 100644
--- a/docs/nfd_user_cfg.txt
+++ b/docs/nfd_user_cfg.txt
@@ -180,6 +180,18 @@
  *                          default NFP_NET_CFG_RSS_TOEPLITZ
  */
 
+/**
+ * TLV defines
+ * @NFD_USE_TLV             Maybe set by the user, otherwise set by
+ *                          NFD  in nfd_cfg.h (microC) if
+ *                          NFD_USE_TLV_XYZ is defined.
+ * @NFD_USE_TLV_XYZ         Specify which vNIC types use TLVs.
+ *                          "XYZ" can be PF,  CTRL, or VF.
+ * @NFD_CFG_TLV_BLOCK_SZ    Number of bytes in TLV block.  Must be
+ *                          4B multiple.
+ * @NFD_CFG_TLV_BLOCK_OFF   Start offset of TLV block in vNIC BAR.
+ *                          Must be 4B multiple.
+ */
 
 /**
  * NFD user context within PCIe island
diff --git a/me/blocks/vnic/shared/nfd_cfg.h b/me/blocks/vnic/shared/nfd_cfg.h
index 52471e0a..40a3d95f 100644
--- a/me/blocks/vnic/shared/nfd_cfg.h
+++ b/me/blocks/vnic/shared/nfd_cfg.h
@@ -259,6 +259,8 @@ NFD_CFG_RINGS_DECL(3);
 #define NFD_CFG_BAR_ISL(_isl, _vid )            \
     NFD_CFG_BAR(NFD_CFG_BASE_LINK(_isl), (_vid))
 
+
+
 /**
  * @param isl           PCIe island, in the range 0..3
  * @param vid           vNIC ID
@@ -309,12 +311,112 @@ __intrinsic __emem char *nfd_cfg_bar_base(unsigned int isl, unsigned int vid) {
 err:
     /* XXX we are halting on this error because it indicates a serious error
      * the return won't actually execute, and 0 is as good as any other
-     * value.  0x800 == NFD_CFG_BAR_BASE_ISL_INVALID */
+     * value.  0x809 == NFD_CFG_BAR_BASE_ISL_INVALID */
+    local_csr_write(local_csr_mailbox_0, 0x809);
+    local_csr_write(local_csr_mailbox_1, isl);
+    halt();
+    return 0;
+};
+
+
+#if (defined(NFD_USE_TLV_VF) || defined(NFD_USE_TLV_CTRL) || \
+     defined(NFD_USE_TLV_PF))
+
+#ifndef NFD_USE_TLV
+#define NFD_USE_TLV
+#endif
+
+#ifndef NFD_CFG_TLV_BLOCK_SZ
+#error "NFD_CFG_TLV_BLOCK_SZ must be defined if NFD_USE_TLV is set"
+#endif
+
+#if ((NFD_CFG_TLV_BLOCK_SZ % 4) != 0)
+#error "NFD_CFG_TLV_BLOCK_SZ must be a 4B multiple"
+#endif
+
+#ifndef NFD_CFG_TLV_BLOCK_OFF
+#error "NFD_CFG_TLV_BLOCK_OFF must be defined if NFD_USE_TLV is set"
+#endif
+
+#if ((NFD_CFG_TLV_BLOCK_OFF % 4) != 0)
+#error "NFD_CFG_TLV_BLOCK_OFF must be a 4B multiple"
+#endif
+
+#define NFD_TLV_BASE_IND(_x) nfd_cfg_tlv_template##_x
+#define NFD_TLV_BASE(_x) NFD_TLV_BASE_IND(_x)
+
+#define NFD_TLV_BASE_DECLARE(_isl) \
+    _NFP_CHIPRES_ASM(.alloc_mem NFD_TLV_BASE(_isl) emem global	\
+    ((NFD_MAX_VFS + NFD_MAX_CTRL + NFD_MAX_PFS) * NFD_CFG_TLV_BLOCK_SZ) 4)
+
+#define NFD_TLV_BASE_LINK_IND1(_sym)            \
+    ((__emem char *) _link_sym(_sym))
+#define NFD_TLV_BASE_LINK_IND0(_isl)            \
+    NFD_TLV_BASE_LINK_IND1(NFD_TLV_BASE(_isl))
+#define NFD_TLV_BASE_LINK(_isl) NFD_TLV_BASE_LINK_IND0(_isl)
+
+#define NFD_TLV_VID_BASE(_isl, _vid)                            \
+    (NFD_TLV_BASE_LINK(_isl) + (_vid) * NFD_CFG_TLV_BLOCK_SZ)
+
+
+/**
+ * @param isl           PCIe island, in the range 0..3
+ * @param vid           vNIC ID
+ *
+ * This function is not intended for use on the data plane as it is
+ * expensive to extract the BAR pointer.  Supplying an isl not in the
+ * range 0..3 or for a PCIe island not in use with NFD is illegal.
+ * It is caught with a halt().
+ */
+__intrinsic __emem char *nfd_cfg_tlv_tml_base(unsigned int isl,
+                                              unsigned int vid) {
+    __emem char *tlv_base;
+    switch (isl) {
+    case 0:
+        #ifdef NFD_PCIE0_EMEM
+            tlv_base = NFD_TLV_VID_BASE(0, vid);
+        #else
+            goto err;
+        #endif
+        break;
+    case 1:
+        #ifdef NFD_PCIE1_EMEM
+            tlv_base = NFD_TLV_VID_BASE(1, vid);
+        #else
+            goto err;
+        #endif
+        break;
+    case 2:
+        #ifdef NFD_PCIE2_EMEM
+            tlv_base = NFD_TLV_VID_BASE(2, vid);
+        #else
+            goto err;
+        #endif
+        break;
+    case 3:
+        #ifdef NFD_PCIE3_EMEM
+            tlv_base = NFD_TLV_VID_BASE(3, vid);
+        #else
+            goto err;
+        #endif
+        break;
+    default:
+        goto err;
+        break;
+    };
+
+    return tlv_base;
+
+err:
+    /* XXX we are halting on this error because it indicates a serious error
+     * the return won't actually execute, and 0 is as good as any other
+     * value.  0x809 == NFD_CFG_BAR_BASE_ISL_INVALID */
     local_csr_write(local_csr_mailbox_0, 0x809);
     local_csr_write(local_csr_mailbox_1, isl);
     halt();
     return 0;
 };
+#endif /* NFD_USE_TLV */
 
 
 /**
diff --git a/me/blocks/vnic/shared/nfd_cfg_internal.c b/me/blocks/vnic/shared/nfd_cfg_internal.c
index 1a6f9047..2c389e43 100644
--- a/me/blocks/vnic/shared/nfd_cfg_internal.c
+++ b/me/blocks/vnic/shared/nfd_cfg_internal.c
@@ -501,6 +501,10 @@ _nfd_cfg_init_vf_cfg_bar(unsigned int vid)
     __xwrite unsigned int exn_lsc = 0xffffffff;
     __xwrite unsigned int cfg2[] = {NFD_OUT_RX_OFFSET,
                                     NFD_RSS_HASH_FUNC};
+#ifdef NFD_USE_TLV_VF
+    __xwrite unsigned int tlv_wr = (NFP_NET_CFG_TLV_TYPE_RESERVED << 16) | \
+        (NFD_CFG_TLV_BLOCK_OFF - NFP_NET_CFG_TLV_BASE - 4);
+#endif
 
     mem_write64(&cfg, NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_VERSION,
                 sizeof cfg);
@@ -511,6 +515,13 @@ _nfd_cfg_init_vf_cfg_bar(unsigned int vid)
     mem_write8(&cfg2,
                NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_RX_OFFSET,
                sizeof cfg2);
+
+#ifdef NFD_USE_TLV_VF
+    mem_write32(&tlv_wr,
+        NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_TLV_BASE,
+        sizeof(tlv_wr));
+#endif
+
 #endif
 }
 
@@ -530,6 +541,11 @@ _nfd_cfg_init_ctrl_cfg_bar(unsigned int vid)
     __xwrite unsigned int exn_lsc = 0xffffffff;
     __xwrite unsigned int cfg2[] = {NFD_OUT_RX_OFFSET,
                                     NFD_RSS_HASH_FUNC};
+#ifdef NFD_USE_TLV_CTRL
+    __xwrite unsigned int tlv_wr = (NFP_NET_CFG_TLV_TYPE_RESERVED << 16) | \
+        (NFD_CFG_TLV_BLOCK_OFF - NFP_NET_CFG_TLV_BASE - 4);
+#endif
+
 
     mem_write64(&cfg, NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_VERSION,
                 sizeof cfg);
@@ -540,6 +556,12 @@ _nfd_cfg_init_ctrl_cfg_bar(unsigned int vid)
     mem_write8(&cfg2, NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_RX_OFFSET,
                sizeof cfg2);
 
+#ifdef NFD_USE_TLV_CTRL
+    mem_write32(&tlv_wr,
+        NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_TLV_BASE,
+        sizeof(tlv_wr));
+#endif
+
 }
 
 
@@ -558,6 +580,11 @@ _nfd_cfg_init_pf_cfg_bar(unsigned int vid)
     __xwrite unsigned int exn_lsc = 0xffffffff;
     __xwrite unsigned int cfg2[] = {NFD_OUT_RX_OFFSET,
                                     NFD_RSS_HASH_FUNC};
+#ifdef NFD_USE_TLV_PF
+    __xwrite unsigned int tlv_wr = (NFP_NET_CFG_TLV_TYPE_RESERVED << 16) | \
+        (NFD_CFG_TLV_BLOCK_OFF - NFP_NET_CFG_TLV_BASE - 4);
+#endif
+
 #ifdef NFD_BPF_CAPABLE
 #ifndef NFD_BPF_ABI
 #define NFD_BPF_ABI (NFP_NET_BPF_ABI)
@@ -602,6 +629,12 @@ _nfd_cfg_init_pf_cfg_bar(unsigned int vid)
                NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_BPF_ABI,
                sizeof bpf_cfg);
 #endif
+
+#ifdef NFD_USE_TLV_PF
+    mem_write32(&tlv_wr,
+        NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_TLV_BASE,
+        sizeof(tlv_wr));
+#endif
 }
 
 
diff --git a/me/blocks/vnic/shared/nfd_flr.c b/me/blocks/vnic/shared/nfd_flr.c
index f07b91d9..56c39c3f 100644
--- a/me/blocks/vnic/shared/nfd_flr.c
+++ b/me/blocks/vnic/shared/nfd_flr.c
@@ -153,18 +153,53 @@ nfd_flr_init_cfg_queue(unsigned int pcie_isl, unsigned int vid,
 }
 
 
+/** Init the TLVs in the CFG BAR from the template
+ * @param pcie          PCIe island, in the range 0..3
+ * @param vid           vid number on the PCIe island
+ *
+ */
+#ifdef NFD_USE_TLV
+void
+nfd_flr_init_tlv(const unsigned int pcie, unsigned int vid)
+{
+    __xwrite unsigned int tlv_wr = (NFP_NET_CFG_TLV_TYPE_RESERVED << 16) | \
+        (NFD_CFG_TLV_BLOCK_SZ - NFP_NET_CFG_TLV_BASE - 4);
+    __emem char *bar_base = nfd_cfg_bar_base(pcie, vid);
+    __emem char *tlv_base = nfd_cfg_tlv_tml_base(pcie, vid);
+
+    unsigned int i, offset, size;
+    __xread unsigned int read_block[16];
+    __xwrite unsigned int write_block[16];
+
+    mem_write32(&tlv_wr, tlv_base + NFP_NET_CFG_TLV_BASE, sizeof(tlv_wr));
+
+    for (offset = 0; offset < NFD_CFG_TLV_BLOCK_SZ;
+         offset += sizeof(read_block)) {
+        mem_read32(read_block, tlv_base + offset, sizeof(read_block));
+
+        reg_cp(write_block, read_block, sizeof(read_block));
+
+        size = NFD_CFG_TLV_BLOCK_SZ - offset;
+        if (size > sizeof(write_block))
+            size = sizeof(write_block);
+
+        mem_write32(write_block, bar_base + NFD_CFG_TLV_BLOCK_OFF + offset,
+                    size);
+    }
+}
+#endif
+
 /** Init the non-zero parts of the PF control BAR
- * @param isl_base      start address of the CFG BARs for the PCIe island
+ * @param pcie          PCIe island, in the range 0..3
  * @param vid           vid number on the PCIe island
  *
- * "isl_base" should be obtained via the appropriate API,
- * e.g. NFD_CFG_BASE_LINK.
  */
 void
-nfd_flr_init_pf_cfg_bar(__emem char *isl_base, unsigned int vid)
+nfd_flr_init_pf_cfg_bar(unsigned int pcie, unsigned int vid)
 {
 #if (NFD_MAX_PFS != 0)
     unsigned int q_base = NFD_VID2NATQ(vid, 0);
+    __emem char *bar_base = nfd_cfg_bar_base(pcie, vid);
     __xwrite unsigned int cfg[] = {NFD_CFG_VERSION(PF),
                                    (NFP_NET_CFG_STS_LINK_RATE_UNSUPPORTED
                                     << NFP_NET_CFG_STS_LINK_RATE_SHIFT) | 0,
@@ -176,6 +211,7 @@ nfd_flr_init_pf_cfg_bar(__emem char *isl_base, unsigned int vid)
     __xwrite unsigned int exn_lsc = 0xffffffff;
     __xwrite unsigned int cfg2[] = {NFD_OUT_RX_OFFSET,
                                     NFD_RSS_HASH_FUNC};
+
 #ifdef NFD_BPF_CAPABLE
 #ifndef NFD_BPF_ABI
 #define NFD_BPF_ABI (NFP_NET_BPF_ABI)
@@ -206,37 +242,36 @@ nfd_flr_init_pf_cfg_bar(__emem char *isl_base, unsigned int vid)
             NFD_LAST_PF_MAX_QUEUES;
     }
 #endif
-    mem_write64(&cfg,
-                NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_VERSION,
-                sizeof cfg);
+    mem_write64(&cfg, bar_base + NFP_NET_CFG_VERSION, sizeof cfg);
 
-    mem_write8(&exn_lsc, NFD_CFG_BAR(isl_base, vid) +
-               NFP_NET_CFG_LSC, sizeof exn_lsc);
+    mem_write8(&exn_lsc, bar_base + NFP_NET_CFG_LSC, sizeof exn_lsc);
 
-    mem_write8(&cfg2,
-               NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_RX_OFFSET,
-               sizeof cfg2);
+    mem_write8(&cfg2, bar_base + NFP_NET_CFG_RX_OFFSET, sizeof cfg2);
 #ifdef NFD_BPF_CAPABLE
-    mem_write8(&bpf_cfg,
-               NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_BPF_ABI,
-               sizeof bpf_cfg);
+    mem_write8(&bpf_cfg, bar_base + NFP_NET_CFG_BPF_ABI, sizeof bpf_cfg);
+#endif
+
+#ifdef NFD_USE_TLV_PF
+    nfd_flr_init_tlv(pcie, vid);
 #endif
+
 #endif
 }
 
 
 /** Init the non-zero parts of the CTRL control BAR
- * @param isl_base      start address of the CFG BARs for the PCIe island
+ * @param pcie          PCIe island, in the range 0..3
  * @param vid           vid number on the PCIe island
  *
  * "isl_base" should be obtained via the appropriate API,
  * e.g. NFD_CFG_BASE_LINK.
  */
 void
-nfd_flr_init_ctrl_cfg_bar(__emem char *isl_base, unsigned int vid)
+nfd_flr_init_ctrl_cfg_bar(unsigned int pcie, unsigned int vid)
 {
 #ifdef NFD_USE_CTRL
     unsigned int q_base = NFD_VID2NATQ(vid, 0);
+    __emem char *bar_base = nfd_cfg_bar_base(pcie, vid);
     __xwrite unsigned int cfg[] = {NFD_CFG_VERSION(CTRL),
                                    (NFP_NET_CFG_STS_LINK_RATE_UNSUPPORTED
                                     << NFP_NET_CFG_STS_LINK_RATE_SHIFT) | 0,
@@ -249,30 +284,30 @@ nfd_flr_init_ctrl_cfg_bar(__emem char *isl_base, unsigned int vid)
     __xwrite unsigned int cfg2[] = {NFD_OUT_RX_OFFSET,
                                     NFD_RSS_HASH_FUNC};
 
-    mem_write64(&cfg,
-                NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_VERSION,
-                sizeof cfg);
+    mem_write64(&cfg, bar_base + NFP_NET_CFG_VERSION, sizeof cfg);
+
+    mem_write8(&exn_lsc, bar_base + NFP_NET_CFG_LSC, sizeof exn_lsc);
 
-    mem_write8(&exn_lsc, NFD_CFG_BAR(isl_base, vid) +
-               NFP_NET_CFG_LSC, sizeof exn_lsc);
+    mem_write8(&cfg2, bar_base + NFP_NET_CFG_RX_OFFSET, sizeof cfg2);
+
+#ifdef NFD_USE_TLV_CTRL
+    nfd_flr_init_tlv(pcie, vid);
+#endif
 
-    mem_write8(&cfg2,
-               NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_RX_OFFSET,
-               sizeof cfg2);
 #endif
 }
 
 
 
 /** Init the non-zero parts of the VF control BAR
- * @param isl_base      start address of the CFG BARs for the PCIe island
+ * @param vf_cfg_base   start address of the VF CFG symbol for the PCIe island
+ * @param pcie          PCIe island, in the range 0..3
  * @param vid           vid number on the PCIe island
  *
- * "isl_base" should be obtained via the appropriate API,
- * e.g. NFD_CFG_BASE_LINK.
  */
 void
-nfd_flr_init_vf_cfg_bar(__emem char *isl_base, __emem char *vf_cfg_base, unsigned int vid)
+nfd_flr_init_vf_cfg_bar(__emem char *vf_cfg_base, unsigned int pcie,
+                        unsigned int vid)
 {
 #if ((NFD_MAX_VFS != 0) && (NFD_MAX_VF_QUEUES != 0))
 #ifdef NFD_NO_ISOLATION
@@ -280,6 +315,7 @@ nfd_flr_init_vf_cfg_bar(__emem char *isl_base, __emem char *vf_cfg_base, unsigne
 #else
     unsigned int q_base = 0;
 #endif
+    __emem char *bar_base = nfd_cfg_bar_base(pcie, vid);
     __xwrite unsigned int cfg[] = {NFD_CFG_VERSION(VF),
                                    (NFP_NET_CFG_STS_LINK_RATE_UNSUPPORTED
                                     << NFP_NET_CFG_STS_LINK_RATE_SHIFT) | 0,
@@ -294,21 +330,21 @@ nfd_flr_init_vf_cfg_bar(__emem char *isl_base, __emem char *vf_cfg_base, unsigne
     __xread unsigned int vf_cfg_rd[2];
     __xwrite unsigned int vf_cfg_wr[2];
 
-    mem_write64(&cfg, NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_VERSION,
-                sizeof cfg);
+    mem_write64(&cfg, bar_base + NFP_NET_CFG_VERSION, sizeof cfg);
 
-    mem_write8(&exn_lsc, NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_LSC,
-               sizeof exn_lsc);
+    mem_write8(&exn_lsc, bar_base + NFP_NET_CFG_LSC, sizeof exn_lsc);
 
-    mem_write8(&cfg2, NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_RX_OFFSET,
-               sizeof cfg2);
+    mem_write8(&cfg2, bar_base + NFP_NET_CFG_RX_OFFSET, sizeof cfg2);
 
     /* XXX should vid technically be vf below? */
     mem_read8(&vf_cfg_rd, NFD_VF_CFG_ADDR(vf_cfg_base, vid),
               NFD_VF_CFG_MAC_SZ);
     reg_cp(vf_cfg_wr, vf_cfg_rd, sizeof vf_cfg_rd);
-    mem_write8(&vf_cfg_wr, NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_MACADDR,
-              NFD_VF_CFG_MAC_SZ);
+    mem_write8(&vf_cfg_wr, bar_base + NFP_NET_CFG_MACADDR, NFD_VF_CFG_MAC_SZ);
+
+#ifdef NFD_USE_TLV_VF
+    nfd_flr_init_tlv(pcie, vid);
+#endif
 
 #endif
 }
diff --git a/me/blocks/vnic/shared/nfd_tlv.uc b/me/blocks/vnic/shared/nfd_tlv.uc
new file mode 100644
index 00000000..190346b3
--- /dev/null
+++ b/me/blocks/vnic/shared/nfd_tlv.uc
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2018,  Netronome Systems, Inc.  All rights reserved.
+ *
+ * @file          blocks/vnic/shared/nfd_tlv.uc
+ * @brief         NFD macros for defining BAR TLVs
+ */
+#ifndef _BLOCKS__VNIC_SHARED_NFD_TLV_UC_
+#define _BLOCKS__VNIC_SHARED_NFD_TLV_UC_
+
+// inhibit pollution of codeless list file with illegal island scoped resources
+#define __NFP_CHIPRES_H__
+
+#include <nfd_common.h>
+#include <nfd_cfg.uc>
+
+
+/* TODO decide whether to test for NFD_USE_TLV in this file
+ * Users don't have to include it if they don't want to use it?
+ */
+
+
+#ifndef NFD_CFG_TLV_BLOCK_SZ
+    #error "NFD_CFG_TLV_BLOCK_SZ must be defined if TLVs are used"
+#endif
+
+#if ((NFD_CFG_TLV_BLOCK_SZ % 4) != 0)
+#error "NFD_CFG_TLV_BLOCK_SZ must be a 4B multiple"
+#endif
+
+#ifndef NFD_CFG_TLV_BLOCK_OFF
+    #error "NFD_CFG_TLV_BLOCK_OFF must be defined if TLVs are used"
+#endif
+
+#if ((NFD_CFG_TLV_BLOCK_OFF % 4) != 0)
+#error "NFD_CFG_TLV_BLOCK_OFF must be a 4B multiple"
+#endif
+
+#ifdef _ISL
+#warning "_ISL is being redefined"
+#endif
+#define _ISL 0
+#while (_ISL < 4)
+    #if (strstr(NFD_PCIE/**/_ISL/**/_EMEM, emem) == 1)
+        .alloc_mem nfd_cfg_tlv_template/**/_ISL emem global \
+             ((NFD_MAX_VFS + NFD_MAX_CTRL + NFD_MAX_PFS) * \
+             NFD_CFG_TLV_BLOCK_SZ) 4
+    #endif
+    #define_eval _ISL (_ISL + 1)
+#endloop
+#undef _ISL
+
+#define __nfd_tlv_offsets ""
+
+#macro _nfd_tlv_extract_offset(key)
+    #define_eval _NFD_TLV_OFFSET strstr('__nfd_tlv_offsets', '@/**/key')
+    #if (_NFD_TLV_OFFSET <= 0)
+        #define_eval _NFD_TLV_OFFSET 0
+    #else
+        #define_eval __nteo_left strleft('__nfd_tlv_offsets', _NFD_TLV_OFFSET - 1)
+        #define_eval __nteo_right strright('__nfd_tlv_offsets', -_NFD_TLV_OFFSET)
+        #define_eval _NFD_TLV_OFFSET \
+            strright('__nteo_right', -strstr('__nteo_right', ':'))
+        #if (strstr('__nteo_right', '@') <= 0)
+            #define_eval __nfd_tlv_offsets '__nteo_left'
+        #else
+            #define_eval _NFD_TLV_OFFSET \
+                strleft('_NFD_TLV_OFFSET', strstr('_NFD_TLV_OFFSET', '@') - 1)
+            #define_eval __nteo_right \
+                strright('__nteo_right', -strstr('__nteo_right', '@'))
+            #define_eval __nfd_tlv_offsets '__nteo_left/**/@/**/__nteo_right'
+        #endif
+    #endif
+#endm
+
+#macro _nfd_tlv_store_offset(key, value)
+    _nfd_tlv_extract_offset(key)
+    #define_eval __nfd_tlv_offsets '__nfd_tlv_offsets/**/@/**/key/**/:/**/value'
+#endm
+
+
+#macro nfd_tlv_init(PCIE_ISL, vid, type, length, value)
+    #define_eval __NFD_TLV_VID (vid)
+    _nfd_tlv_extract_offset(p/**/PCIE_ISL/**/v/**/__NFD_TLV_VID)
+
+    #define_eval __nfd_tlv_template_addr \
+        ((vid * NFD_CFG_TLV_BLOCK_SZ) + _NFD_TLV_OFFSET)
+    .init nfd_cfg_tlv_template/**/PCIE_ISL/**/+__nfd_tlv_template_addr \
+        ((type << 16) | length)
+
+    #define_eval __nfd_tlv_bar_addr \
+        ((vid * NFP_NET_CFG_BAR_SZ) + NFD_CFG_TLV_BLOCK_OFF +  _NFD_TLV_OFFSET)
+    .init nfd_cfg_base/**/PCIE_ISL/**/+__nfd_tlv_bar_addr \
+        ((type << 16) | length)
+
+    #if (length > 0)
+        #define_eval __nfd_tlv_template_addr (__nfd_tlv_template_addr + 4)
+        .init nfd_cfg_tlv_template/**/PCIE_ISL/**/+__nfd_tlv_template_addr value
+
+        #define_eval __nfd_tlv_bar_addr (__nfd_tlv_bar_addr + 4)
+        .init nfd_cfg_base/**/PCIE_ISL/**/+__nfd_tlv_bar_addr value
+    #endif
+    #define_eval _NFD_TLV_OFFSET (_NFD_TLV_OFFSET + 4 + length)
+    #if (type == NFP_NET_CFG_TLV_TYPE_END)
+        #if (length != 0)
+            #error "NFP_NET_CFG_TLV_TYPE_END must have length = 0"
+        #endif
+    #endif
+    _nfd_tlv_store_offset(p/**/PCIE_ISL/**/v/**/__NFD_TLV_VID, _NFD_TLV_OFFSET)
+    #undef __NFD_TLV_VID
+#endm
+
+#endif /* _BLOCKS__VNIC_SHARED_NFD_TLV_UC_ */
diff --git a/me/blocks/vnic/svc_me.c b/me/blocks/vnic/svc_me.c
index 168d0940..d7b8d722 100644
--- a/me/blocks/vnic/svc_me.c
+++ b/me/blocks/vnic/svc_me.c
@@ -52,6 +52,9 @@ struct nfd_cfg_msg cfg_msg0;
 NFD_CFG_BASE_DECLARE(0);
 NFD_VF_CFG_DECLARE(0);
 NFD_VF_CFG_INIT(0);
+#ifdef NFD_USE_TLV
+NFD_TLV_BASE_DECLARE(0);
+#endif
 
 PCIE_C2P_BAR_ALLOC_OFF(nfd_scv_qmon_bar0, me, 0, PCIE_CPP2PCIE_QMON, 1);
 #endif
@@ -65,6 +68,9 @@ struct nfd_cfg_msg cfg_msg1;
 NFD_CFG_BASE_DECLARE(1);
 NFD_VF_CFG_DECLARE(1);
 NFD_VF_CFG_INIT(1);
+#ifdef NFD_USE_TLV
+NFD_TLV_BASE_DECLARE(1);
+#endif
 
 PCIE_C2P_BAR_ALLOC_OFF(nfd_svc_qmon_bar1, me, 1, PCIE_CPP2PCIE_QMON, 1);
 #endif
@@ -78,6 +84,9 @@ struct nfd_cfg_msg cfg_msg2;
 NFD_CFG_BASE_DECLARE(2);
 NFD_VF_CFG_DECLARE(2);
 NFD_VF_CFG_INIT(2);
+#ifdef NFD_USE_TLV
+NFD_TLV_BASE_DECLARE(2);
+#endif
 
 PCIE_C2P_BAR_ALLOC_OFF(nfd_svc_qmon_bar2, me, 2, PCIE_CPP2PCIE_QMON, 1);
 #endif
@@ -91,6 +100,9 @@ struct nfd_cfg_msg cfg_msg3;
 NFD_CFG_BASE_DECLARE(3);
 NFD_VF_CFG_DECLARE(3);
 NFD_VF_CFG_INIT(3);
+#ifdef NFD_USE_TLV
+NFD_TLV_BASE_DECLARE(3);
+#endif
 
 PCIE_C2P_BAR_ALLOC_OFF(nfd_svc_qmon_bar3, me, 3, PCIE_CPP2PCIE_QMON, 1);
 #endif
@@ -122,19 +134,16 @@ do {                                                                    \
                                                                         \
             if (NFD_VID_IS_PF(cfg_msg##_isl.vid)) {                     \
                 /* We have a PF FLR */                                  \
-                nfd_flr_init_pf_cfg_bar(NFD_CFG_BASE_LINK(_isl),        \
-                                        cfg_msg##_isl.vid);             \
+                nfd_flr_init_pf_cfg_bar(_isl, cfg_msg##_isl.vid);       \
                                                                         \
             } else if (NFD_VID_IS_VF(cfg_msg##_isl.vid)) {              \
                 /* We have a VF FLR */                                  \
-                nfd_flr_init_vf_cfg_bar(NFD_CFG_BASE_LINK(_isl),        \
-                                        NFD_VF_CFG_BASE_LINK(_isl),     \
-                                        cfg_msg##_isl.vid);             \
+                nfd_flr_init_vf_cfg_bar(NFD_VF_CFG_BASE_LINK(_isl),     \
+                                        _isl, cfg_msg##_isl.vid);	\
                                                                         \
             } else {                                                    \
                 /* We have a PF/CTRL FLR */                             \
-                nfd_flr_init_ctrl_cfg_bar(NFD_CFG_BASE_LINK(_isl),      \
-                                          cfg_msg##_isl.vid);           \
+                nfd_flr_init_ctrl_cfg_bar(_isl, cfg_msg##_isl.vid);     \
                                                                         \
             }                                                           \
         }                                                               \
