diff --git a/docs/nfd_user_cfg.txt b/docs/nfd_user_cfg.txt
--- a/docs/nfd_user_cfg.txt
+++ b/docs/nfd_user_cfg.txt
@@ -135,12 +135,19 @@
  *                              provides.
  */
 
 /**
+ * VF CFG defines (support for *ndo_set_vf_xyz call backs)
+ * see shared/nfd_vf_cfg_iface*
+ * @NFD_VF_CFG_ABI_VER  ABI version number to support (1 or 2 currently)
+ * @NFD_VF_CFG_CAP      Capabilities to advertise for ABI 2
+ */
+
+/**
  * eBPF defines
  * @NFD_BPF_CAPABLE     Firmware can handle eBPF offload, advertise ABI info
  * @NFD_BPF_CAPS        Mask of application specific BPF capability bits
- *                      (see NFP_NET_CFG_BPF_CAP in kernel/nfp_net_ctrl.h) 
+ *                      (see NFP_NET_CFG_BPF_CAP in kernel/nfp_net_ctrl.h)
  * @NFD_BPF_START_OFF   Offset at which BPF will be loaded
  * @NFD_BPF_DONE_OFF    Offset to jump to on exit
  * @NFD_BPF_MAX_LEN     Maximum BPF program length in instruction words
  */
diff --git a/me/apps/loopback/nfd_user_cfg.h b/me/apps/loopback/nfd_user_cfg.h
--- a/me/apps/loopback/nfd_user_cfg.h
+++ b/me/apps/loopback/nfd_user_cfg.h
@@ -137,5 +137,10 @@
 
 #define PKT_NBI_OFFSET          64
 #define INGRESS_MAC_PREPEND_BYTES   8
 
+#define NFD_VF_CFG_ABI_VER      2
+#define NFD_VF_CFG_CAP                                       \
+    (NFD_VF_CFG_MB_UPD_MAC | NFD_VF_CFG_MB_UPD_VLAN |        \
+     NFD_VF_CFG_MB_UPD_SPOOF | NFD_VF_CFG_MB_UPD_LINK_STATE)
+
 #endif /* !_BLOCKS__VNIC_PCI_IN_H_ */
diff --git a/me/blocks/vnic/shared/nfd_vf_cfg_iface.h b/me/blocks/vnic/shared/nfd_vf_cfg_iface.h
--- a/me/blocks/vnic/shared/nfd_vf_cfg_iface.h
+++ b/me/blocks/vnic/shared/nfd_vf_cfg_iface.h
@@ -1,6 +1,6 @@
 /*
- * Copyright (C) 2016,  Netronome Systems, Inc.  All rights reserved.
+ * Copyright (C) 2016-2017,  Netronome Systems, Inc.  All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -22,56 +22,17 @@
 #if defined(__NFP_LANG_MICROC) || defined (__NFP_LANG_ASM)
 #include <nfd_user_cfg.h>
 #endif
 
+/* ABI version can be overridden in nfd_user_cfg.h */
+#ifndef NFD_VF_CFG_ABI_VER
 #define NFD_VF_CFG_ABI_VER      1
-
-/* Field defines, supporting MAC and VLAN values in this ABI version */
-#define NFD_VF_CFG_MAC_HI_fld   0, 31, 0
-#define NFD_VF_CFG_MAC_HI_msk   0xffffffff
-#define NFD_VF_CFG_MAC_HI_wrd   0
-#define NFD_VF_CFG_MAC_LO_fld   1, 31, 16
-#define NFD_VF_CFG_MAC_LO_msk   0xffff
-#define NFD_VF_CFG_MAC_LO_sft   16
-#define NFD_VF_CFG_MAC_LO_wrd   1
-#define NFD_VF_CFG_MAC_SZ       6
-#define NFD_VF_CFG_VLAN_fld     1, 15, 0
-#define NFD_VF_CFG_VLAN_msk     0xffff
-#define NFD_VF_CFG_VLAN_shf     0
-#define NFD_VF_CFG_VLAN_wrd     1
-
-#define NFD_VF_CFG_SZ           8
-#define NFD_VF_CFG_OFF(_vf)     (NFD_VF_CFG_SZ * _vf)
-
-#define NFD_VF_CFG_MAX_VFS_SZ           4
-
-
-#if defined(__NFP_LANG_MICROC)
-/* Expose NFD_MAX_VFS to the host */
-#define NFD_VF_CFG_MAX_VFS                                    \
-    __asm { .alloc_mem nfd_vf_cfg_max_vfs emem global 8 8 }   \
-    __asm { .init nfd_vf_cfg_max_vfs NFD_MAX_VFS }
-
-#define NFD_VF_CFG_BASE_IND2(_x, _abi) _pf##_x##_net_vf_cfg##_abi
-#define NFD_VF_CFG_BASE_IND1(_x, _abi) NFD_VF_CFG_BASE_IND2(_x, _abi)
-#define NFD_VF_CFG_BASE(_x) NFD_VF_CFG_BASE_IND1(_x, NFD_VF_CFG_ABI_VER)
-
-/* MicroC declaration of per island symbol */
-#define NFD_VF_CFG_DECLARE(_isl)                                    \
-    __asm{ .alloc_mem NFD_VF_CFG_BASE(_isl) emem global             \
-            (NFD_MAX_VFS * NFD_VF_CFG_SZ)                           \
-            NFD_VF_CFG_SZ }
-
-/* MicroC access to per island symbol */
-#define NFD_VF_CFG_BASE_LINK_IND1(_sym)         \
-    ((__emem char *) _link_sym(_sym))
-#define NFD_VF_CFG_BASE_LINK_IND0(_isl)                 \
-    NFD_VF_CFG_BASE_LINK_IND1(NFD_VF_CFG_BASE(_isl))
-#define NFD_VF_CFG_BASE_LINK(_isl) NFD_VF_CFG_BASE_LINK_IND0(_isl)
-
-/* MicroC access to per VF data address */
-#define NFD_VF_CFG_ADDR(_base, _vf)           \
-    ((_base) + NFD_VF_CFG_OFF(_vf))
 #endif
 
+#if (NFD_VF_CFG_ABI_VER == 1)
+#include "nfd_vf_cfg_iface_abi1.h"
+#elif (NFD_VF_CFG_ABI_VER == 2)
+#include "nfd_vf_cfg_iface_abi2.h"
+#endif
+
 
 #endif /* !_BLOCKS__SHARED_NFD_VF_CFG_IFACE_H_ */
diff --git a/me/blocks/vnic/shared/nfd_vf_cfg_iface.uc b/me/blocks/vnic/shared/nfd_vf_cfg_iface.uc
--- a/me/blocks/vnic/shared/nfd_vf_cfg_iface.uc
+++ b/me/blocks/vnic/shared/nfd_vf_cfg_iface.uc
@@ -1,6 +1,6 @@
 /*
- * Copyright (C) 2016,  Netronome Systems, Inc.  All rights reserved.
+ * Copyright (C) 2016-2017,  Netronome Systems, Inc.  All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * @file          blocks/vnic/shared/nfd_vf_cfg_iface.h
- * @brief         Interface to per VF configuration for *ndo_set/get functions
+ * @brief         Interface to per VF config for *ndo_set/get functions
  */
 
 #ifndef _BLOCKS__SHARED_NFD_VF_CFG_IFACE_UC_
 #define _BLOCKS__SHARED_NFD_VF_CFG_IFACE_UC_
@@ -25,15 +25,34 @@
 #include <nfd_user_cfg.h>
 
 #include <vnic/shared/nfd_vf_cfg_iface.h>
 
-/* Microcode declaration of per island symbol */
+/* Microcode declarations of per island symbol */
 #macro nfd_vf_cfg_declare(isl)
     .alloc_mem _pf/**/isl/**/_net_vf_cfg/**/NFD_VF_CFG_ABI_VER \
-         NFD_PCIE/**/isl/**/_EMEM global \
-         (NFD_MAX_VFS * NFD_VF_CFG_SZ) NFD_VF_CFG_SZ
+        emem global (NFD_VF_CFG_MB_SZ + (NFD_MAX_VFS * NFD_VF_CFG_SZ)) \
+        NFD_VF_CFG_SZ
 #endm
 
+#macro nfd_vf_cfg_declare_all()
+    #ifdef NFD_PCIE0_EMEM
+        nfd_vf_cfg_declare(0)
+    #endif
+
+    #ifdef NFD_PCIE1_EMEM
+        nfd_vf_cfg_declare(1)
+    #endif
+
+    #ifdef NFD_PCIE2_EMEM
+        nfd_vf_cfg_declare(2)
+    #endif
+
+    #ifdef NFD_PCIE3_EMEM
+        nfd_vf_cfg_declare(3)
+    #endif
+#endm
+
+
 /* Microcode access to per island start address */
 #macro nfd_vf_cfg_base(addr_hi, addr_lo, isl)
 #if (!is_ct_const(isl))
     #error "nfd_vf_cfg_base: isl must be compile time constant"
@@ -44,11 +63,13 @@
 
 /* Microcode access to per VF data offset within per island symbol */
 #macro nfd_vf_cfg_offset(off, vf)
     alu[off, --, b, vf, <<(log2(NFD_VF_CFG_SZ))]
+#if (NFD_VF_CFG_MB_SZ > 0)
+    alu[off, off, +, NFD_VF_CFG_MB_SZ]
+#endif
 #endm
 
-
 /* Microcode access to per VF data address */
 #macro nfd_vf_cfg_addr(addr_hi, addr_lo, isl, vf)
 .begin
     .reg offset
@@ -59,5 +80,5 @@
     alu[addr_hi, addr_hi, +carry, 0]
 .end
 #endm
 
-#endif /* _BLOCKS__SHARED_NFD_VF_CFG_IFACE_UC_ */
\ No newline at end of file
+#endif /* _BLOCKS__SHARED_NFD_VF_CFG_IFACE_UC_ */
diff --git a/me/blocks/vnic/shared/nfd_vf_cfg_iface_abi1.h b/me/blocks/vnic/shared/nfd_vf_cfg_iface_abi1.h
new file mode 100644
--- /dev/null
+++ b/me/blocks/vnic/shared/nfd_vf_cfg_iface_abi1.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2017,  Netronome Systems, Inc.  All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * @file          blocks/vnic/shared/nfd_vf_cfg_iface_abi1.h
+ * @brief         ABI v1 for per VF configuration for *ndo_set/get functions
+ */
+#ifndef _BLOCKS__SHARED_NFD_VF_CFG_IFACE_ABI1_H_
+#define _BLOCKS__SHARED_NFD_VF_CFG_IFACE_ABI1_H_
+
+/* VF config entry field defines,
+ * MAC and VLAN values supported in this ABI version */
+#define NFD_VF_CFG_SZ           8
+#define NFD_VF_CFG_MAC_HI_fld   0, 31, 0
+#define NFD_VF_CFG_MAC_HI_msk   0xffffffff
+#define NFD_VF_CFG_MAC_HI_wrd   0
+#define NFD_VF_CFG_MAC_LO_fld   1, 31, 16
+#define NFD_VF_CFG_MAC_LO_msk   0xffff
+#define NFD_VF_CFG_MAC_LO_shf   16
+#define NFD_VF_CFG_MAC_LO_wrd   1
+#define NFD_VF_CFG_MAC_SZ       6
+#define NFD_VF_CFG_VLAN_fld     1, 15, 0
+#define NFD_VF_CFG_VLAN_msk     0xffff
+#define NFD_VF_CFG_VLAN_shf     0
+#define NFD_VF_CFG_VLAN_wrd     1
+
+/* VF config mailbox entry defines
+ * XXX ABI 1 doesn't use a mailbox, but provide a zero size define
+ * so that macros can be shared between ABI1 and ABI2 */
+#define NFD_VF_CFG_MB_SZ        0
+
+#define NFD_VF_CFG_MAX_VFS_SZ   4
+
+#define NFD_VF_CFG_OFF(_vf) (NFD_VF_CFG_MB_SZ + (NFD_VF_CFG_SZ * (_vf)))
+
+#if defined(__NFP_LANG_MICROC)
+/* Expose NFD_MAX_VFS to the host */
+#define NFD_VF_CFG_MAX_VFS                                    \
+    __asm { .alloc_mem nfd_vf_cfg_max_vfs emem global 8 8 }   \
+    __asm { .init nfd_vf_cfg_max_vfs NFD_MAX_VFS }
+
+#define NFD_VF_CFG_BASE_IND2(_isl, _abi) _pf##_x##_net_vf_cfg##_abi
+#define NFD_VF_CFG_BASE_IND1(_isl, _abi) NFD_VF_CFG_BASE_IND2(_isl, _abi)
+#define NFD_VF_CFG_BASE(_isl) NFD_VF_CFG_BASE_IND1(_isl, NFD_VF_CFG_ABI_VER)
+
+/* MicroC declaration of per island symbol */
+#define NFD_VF_CFG_DECLARE(_isl)                                    \
+    __asm{ .alloc_mem NFD_VF_CFG_BASE(_isl) emem global             \
+            (NFD_VF_CFG_MB_SZ + (NFD_MAX_VFS * NFD_VF_CFG_SZ))      \
+            NFD_VF_CFG_SZ }
+
+#ifdef NFD_VF_CFG_CAP
+#warning "NFD_VF_CFG_CAP is not used for NFD_VF_CFG_ABI_VER 1"
+#endif
+#define NFD_VF_CFG_INIT(_isl)
+
+/* MicroC access to per island symbol */
+#define NFD_VF_CFG_BASE_LINK_IND1(_sym)         \
+    ((__emem char *) _link_sym(_sym))
+#define NFD_VF_CFG_BASE_LINK_IND0(_isl)                 \
+    NFD_VF_CFG_BASE_LINK_IND1(NFD_VF_CFG_BASE(_isl))
+#define NFD_VF_CFG_BASE_LINK(_isl) NFD_VF_CFG_BASE_LINK_IND0(_isl)
+
+/* MicroC access to per VF data address */
+#define NFD_VF_CFG_ADDR(_base, _vf)           \
+    ((_base) + NFD_VF_CFG_OFF(_vf))
+
+#endif
+
+
+#endif /* !_BLOCKS__SHARED_NFD_VF_CFG_IFACE_ABI1_H_ */
diff --git a/me/blocks/vnic/shared/nfd_vf_cfg_iface_abi2.h b/me/blocks/vnic/shared/nfd_vf_cfg_iface_abi2.h
new file mode 100644
--- /dev/null
+++ b/me/blocks/vnic/shared/nfd_vf_cfg_iface_abi2.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2017,  Netronome Systems, Inc.  All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * @file          blocks/vnic/shared/nfd_vf_cfg_iface_abi2.h
+ * @brief         ABI v2 for per VF configuration for *ndo_set/get functions
+ */
+#ifndef _BLOCKS__SHARED_NFD_VF_CFG_IFACE_ABI2_H_
+#define _BLOCKS__SHARED_NFD_VF_CFG_IFACE_ABI2_H_
+
+/* VF config mailbox */
+#define NFD_VF_CFG_MB_SZ                16
+#define NFD_VF_CFG_MB_ofs               0x0
+#define NFD_VF_CFG_MB_RESP_fld          0, 31, 16
+#define NFD_VF_CFG_MB_RESP_msk          0xffff
+#define NFD_VF_CFG_MB_RESP_shf          16
+#define NFD_VF_CFG_MB_RESP_wrd          0
+#define NFD_VF_CFG_MB_CAP_fld           0, 15, 0
+#define NFD_VF_CFG_MB_CAP_msk           0xffff
+#define NFD_VF_CFG_MB_CAP_shf           0
+#define NFD_VF_CFG_MB_CAP_wrd           0
+#define   NFD_VF_CFG_MB_CAP_MAC         (0x1 << 0)
+#define   NFD_VF_CFG_MB_CAP_VLAN        (0x1 << 1)
+#define   NFD_VF_CFG_MB_CAP_SPOOF       (0x1 << 2)
+#define   NFD_VF_CFG_MB_CAP_LINK_STATE  (0x1 << 3)
+#define NFD_VF_CFG_MB_VF_NUM_fld        1, 31, 24
+#define NFD_VF_CFG_MB_VF_NUM_msk        0xff
+#define NFD_VF_CFG_MB_VF_NUM_shf        24
+#define NFD_VF_CFG_MB_VF_NUM_wrd        1
+#define NFD_VF_CFG_MB_UPD_ofs           0x4
+#define NFD_VF_CFG_MB_UPD_fld           1, 15, 0
+#define NFD_VF_CFG_MB_UPD_msk           0xffff
+#define NFD_VF_CFG_MB_UPD_shf           0
+#define NFD_VF_CFG_MB_UPD_wrd           1
+#define   NFD_VF_CFG_MB_UPD_MAC         (0x1 << 0)
+#define   NFD_VF_CFG_MB_UPD_VLAN        (0x1 << 1)
+#define   NFD_VF_CFG_MB_UPD_SPOOF       (0x1 << 2)
+#define   NFD_VF_CFG_MB_UPD_LINK_STATE  (0x1 << 3)
+
+/* VF config entry */
+#define NFD_VF_CFG_SZ                       16
+#define NFD_VF_CFG_MAC_SZ                   6
+#define NFD_VF_CFG_MAC_ofs                  0x0
+#define   NFD_VF_CFG_MAC_HI_fld             0, 31, 0
+#define   NFD_VF_CFG_MAC_HI_msk             0xffffffff
+#define   NFD_VF_CFG_MAC_HI_shf             0
+#define   NFD_VF_CFG_MAC_HI_wrd             0
+#define   NFD_VF_CFG_MAC_LO_fld             1, 31, 16
+#define   NFD_VF_CFG_MAC_LO_msk             0xffff
+#define   NFD_VF_CFG_MAC_LO_shf             16
+#define   NFD_VF_CFG_MAC_LO_wrd             1
+#define NFD_VF_CFG_CTRL_ofs                 0x4
+#define NFD_VF_CFG_CTRL_fld                 1, 7, 0
+#define NFD_VF_CFG_CTRL_msk                 0xff
+#define NFD_VF_CFG_CTRL_shf                 0
+#define NFD_VF_CFG_CTRL_wrd                 1
+#define   NFD_VF_CFG_CTRL_SPOOF_fld         1, 2, 2
+#define   NFD_VF_CFG_CTRL_SPOOF_msk         1
+#define   NFD_VF_CFG_CTRL_SPOOF_shf         2
+#define   NFD_VF_CFG_CTRL_SPOOF_wrd         1
+#define   NFD_VF_CFG_CTRL_LINK_STATE_fld    1, 1, 0
+#define   NFD_VF_CFG_CTRL_LINK_STATE_msk    3
+#define   NFD_VF_CFG_CTRL_LINK_STATE_shf    0
+#define   NFD_VF_CFG_CTRL_LINK_STATE_wrd    1
+#define     NFD_VF_CFG_CTRL_LINK_STATE_AUTO     0
+#define     NFD_VF_CFG_CTRL_LINK_STATE_ENABLE   1
+#define     NFD_VF_CFG_CTRL_LINK_STATE_DISABLE  2
+#define NFD_VF_CFG_VLAN_ofs                 0x8
+#define NFD_VF_CFG_VLAN_PROTO_fld           2, 31, 16
+#define NFD_VF_CFG_VLAN_PROTO_msk           0xffff
+#define NFD_VF_CFG_VLAN_PROTO_shf           0
+#define NFD_VF_CFG_VLAN_PROTO_wrd           2
+#define NFD_VF_CFG_VLAN_fld                 2, 15, 0
+#define NFD_VF_CFG_VLAN_msk                 0xffff
+#define NFD_VF_CFG_VLAN_shf                 0
+#define NFD_VF_CFG_VLAN_wrd                 2
+#define  NFD_VF_CFG_VLAN_QOS_fld         2, 15, 13
+#define  NFD_VF_CFG_VLAN_QOS_msk         7
+#define  NFD_VF_CFG_VLAN_QOS_shf         13
+#define  NFD_VF_CFG_VLAN_QOS_wrd         2
+#define  NFD_VF_CFG_VLAN_VID_fld         2, 11, 0
+#define  NFD_VF_CFG_VLAN_VID_msk         0xfff
+#define  NFD_VF_CFG_VLAN_VID_shf         0
+#define  NFD_VF_CFG_VLAN_VID_wrd         2
+
+
+#define NFD_VF_CFG_MAX_VFS_SZ   4
+
+#define NFD_VF_CFG_OFF(_vf) (NFD_VF_CFG_MB_SZ + (NFD_VF_CFG_SZ * (_vf)))
+
+
+#if defined(__NFP_LANG_MICROC)
+/* Expose NFD_MAX_VFS to the host */
+#define NFD_VF_CFG_MAX_VFS                                    \
+    __asm { .alloc_mem nfd_vf_cfg_max_vfs emem global 8 8 }   \
+    __asm { .init nfd_vf_cfg_max_vfs NFD_MAX_VFS }
+
+#define NFD_VF_CFG_BASE_IND2(_isl, _abi) _pf##_isl##_net_vf_cfg##_abi
+#define NFD_VF_CFG_BASE_IND1(_isl, _abi) NFD_VF_CFG_BASE_IND2(_isl, _abi)
+#define NFD_VF_CFG_BASE(_isl) NFD_VF_CFG_BASE_IND1(_isl, NFD_VF_CFG_ABI_VER)
+
+/* MicroC declaration of per island symbol */
+#if (NFD_VF_CFG_MB_SZ != NFD_VF_CFG_SZ)
+#error "NFD_VF_CFG_MB_SZ must match NFD_VF_CFG_SZ"
+#endif
+#define NFD_VF_CFG_DECLARE(_isl)                                    \
+    __asm{ .alloc_mem NFD_VF_CFG_BASE(_isl) emem global             \
+            (NFD_VF_CFG_MB_SZ + (NFD_MAX_VFS * NFD_VF_CFG_SZ))      \
+            NFD_VF_CFG_SZ }
+
+#ifndef NFD_VF_CFG_CAP
+#error "NFD_VF_CFG_CAP must be specified for NFD_VF_CFG_ABI_VER 2"
+#endif
+#if (NFD_VF_CFG_CAP > NFD_VF_CFG_MB_CAP_msk)
+#error "NFD_VF_CFG_CAP seems invalid"
+#endif
+#define NFD_VF_CFG_INIT(_isl)                            \
+    __asm{ .init NFD_VF_CFG_BASE(_isl)+NFD_VF_CFG_MB_ofs \
+            ((NFD_VF_CFG_MB_CAP_msk & (NFD_VF_CFG_CAP))  \
+             << NFD_VF_CFG_MB_CAP_shf)}
+
+/* MicroC access to per island symbol */
+#define NFD_VF_CFG_BASE_LINK_IND1(_sym)         \
+    ((__emem char *) _link_sym(_sym))
+#define NFD_VF_CFG_BASE_LINK_IND0(_isl)                 \
+    NFD_VF_CFG_BASE_LINK_IND1(NFD_VF_CFG_BASE(_isl))
+#define NFD_VF_CFG_BASE_LINK(_isl) NFD_VF_CFG_BASE_LINK_IND0(_isl)
+
+/* MicroC access to per VF data address */
+#define NFD_VF_CFG_ADDR(_base, _vf)           \
+    ((_base) + NFD_VF_CFG_OFF(_vf))
+
+/* MicroC VF config mailbox and entry structs */
+struct sriov_mb {
+    union {
+        struct {
+            unsigned int resp:16;
+            unsigned int cap_flags:16;
+            unsigned int vf:8;
+            unsigned int resvd1:8;
+            unsigned int update_flags:16;
+            unsigned int spare0;
+            unsigned int spare1;
+        };
+        unsigned int __raw[4];
+    };
+};
+
+struct sriov_cfg {
+    union {
+        struct {
+            unsigned int mac_hi:32;
+
+            unsigned int mac_lo:16;
+            unsigned int resvd0:8;
+            unsigned int ctrl_flags:8;
+
+            union {
+                struct {
+                    unsigned short vlan_proto;
+                    unsigned short vlan_qos:3;
+                    unsigned short vlan_resvd:1;
+                    unsigned short vlan_id:12;
+                };
+                struct {
+                    unsigned int :16;
+                    unsigned int vlan_tag:16;
+                };
+            };
+
+            unsigned int spare0;
+        };
+        uint32_t __raw[4];
+    };
+};
+
+#endif /* __NFP_LANG_MICROC */
+
+#endif /* !_BLOCKS__SHARED_NFD_VF_CFG_IFACE_ABI2_H_ */
+
diff --git a/me/blocks/vnic/svc_me.c b/me/blocks/vnic/svc_me.c
--- a/me/blocks/vnic/svc_me.c
+++ b/me/blocks/vnic/svc_me.c
@@ -50,8 +50,9 @@
 struct nfd_cfg_msg cfg_msg0;
 
 NFD_CFG_BASE_DECLARE(0);
 NFD_VF_CFG_DECLARE(0);
+NFD_VF_CFG_INIT(0);
 #endif
 
 #ifdef NFD_PCIE1_EMEM
 __visible SIGNAL nfd_cfg_sig_svc_me1;
@@ -60,8 +61,9 @@ NFD_VF_CFG_DECLARE(0);
 struct nfd_cfg_msg cfg_msg1;
 
 NFD_CFG_BASE_DECLARE(1);
 NFD_VF_CFG_DECLARE(1);
+NFD_VF_CFG_INIT(1);
 #endif
 
 #ifdef NFD_PCIE2_EMEM
 __visible SIGNAL nfd_cfg_sig_svc_me2;
@@ -70,8 +72,9 @@ NFD_VF_CFG_DECLARE(1);
 struct nfd_cfg_msg cfg_msg2;
 
 NFD_CFG_BASE_DECLARE(2);
 NFD_VF_CFG_DECLARE(2);
+NFD_VF_CFG_INIT(2);
 #endif
 
 #ifdef NFD_PCIE3_EMEM
 __visible SIGNAL nfd_cfg_sig_svc_me3;
@@ -80,8 +83,9 @@ NFD_VF_CFG_DECLARE(2);
 struct nfd_cfg_msg cfg_msg3;
 
 NFD_CFG_BASE_DECLARE(3);
 NFD_VF_CFG_DECLARE(3);
+NFD_VF_CFG_INIT(3);
 #endif
 
 NFD_FLR_DECLARE;
 NFD_VF_CFG_MAX_VFS;
# HG changeset patch
# User Michael Rapson <michael.rapson@netronome.com>
# Date 1500518092 -7200
# Node ID 7d940609c48d3e59662871257835aea8063c4060
# Parent  e520ec5c7ad7c3eebd5844e61620b3adf018c05f
cfg: Remove stale MAX_QUEUE_NUM define
* MAX_QUEUE_NUM is unused and doesn't account for CTRL vNIC queues

diff --git a/me/blocks/vnic/svc/msix_qmon.c b/me/blocks/vnic/svc/msix_qmon.c
--- a/me/blocks/vnic/svc/msix_qmon.c
+++ b/me/blocks/vnic/svc/msix_qmon.c
@@ -72,10 +72,8 @@
  * core MSI-X logic is only dealing with "queues" and configuration
  * logic translates from "rings" to queues.
  */
 
-#define MAX_QUEUE_NUM (NFD_MAX_VFS * NFD_MAX_VF_QUEUES + \
-                       NFD_MAX_PFS * NFD_MAX_PF_QUEUES - 1)
 #define MAX_NUM_PCI_ISLS 4
 
 
 /*
# HG changeset patch
# User Michael Rapson <michael.rapson@netronome.com>
# Date 1500662990 -7200
# Node ID 4b142d858809109220c04dbbe7b9b1fd7c17f9b8
# Parent  7d940609c48d3e59662871257835aea8063c4060
cfg: Support PF oversubscription

diff --git a/docs/nfd_user_cfg.txt b/docs/nfd_user_cfg.txt
--- a/docs/nfd_user_cfg.txt
+++ b/docs/nfd_user_cfg.txt
@@ -19,16 +19,20 @@
 
 /**
  * Queue number defines
  * The total number of queues allocated must be less than or equal to
- * 64, and the number of queues for each vNIC must be a power of two.
+ * 64 (unless queue oversubscription is used), and the number of queues
+ * for each vNIC must be a power of two.  Queue oversubscription allows
+ * the last PF to receive fewer than NFD_MAX_PF_QUEUES, to keep the
+ * total queues within the 64 limit.
  * Currently NFD_MAX_VF_QUEUES must be 1.  The control vNIC (if used)
  * requires one queue.
  * @NFD_MAX_VFS         Number of virtual function vNICs to support
  * @NFD_MAX_PFS         Number of physical function vNICs to support
  * @NFD_MAX_VF_QUEUES   Number of queues to support per VF vNIC
  * @NFD_MAX_PF_QUEUES   Number of queues to support per PF vNIC
  * @NFD_USE_CTRL        Create control vNIC, requires one queue
+ * @NFD_USE_OVERSUBSCRIPTION    Allow queue oversubscription
  */
 
 /**
  * The app ID is a value that the firmware advertises to the host PF
diff --git a/me/apps/loopback/loopback_main.c b/me/apps/loopback/loopback_main.c
--- a/me/apps/loopback/loopback_main.c
+++ b/me/apps/loopback/loopback_main.c
@@ -321,8 +321,9 @@ void main(void)
                 queue = 0;
             #else
                 type = NFD_VNIC_TYPE_PF;
                 vnic = vnic ^ 1;
+                queue = queue & 7;
                 /* Leave queue untouched */
             #endif
         } else {
             /* This is an error */
diff --git a/me/apps/loopback/loopback_main.uc b/me/apps/loopback/loopback_main.uc
--- a/me/apps/loopback/loopback_main.uc
+++ b/me/apps/loopback/loopback_main.uc
@@ -361,9 +361,9 @@ main#:
                  move(queue, 0)
              #else
                  move(type, NFD_VNIC_TYPE_PF)
                  alu[vnic, vnic, xor, 1]
-                 ; Leave queue untouched
+                 alu[queue, queue, and, 7]
              #endif
             br[route_done#]
         #endif
 
diff --git a/me/blocks/vnic/nfd_common.h b/me/blocks/vnic/nfd_common.h
--- a/me/blocks/vnic/nfd_common.h
+++ b/me/blocks/vnic/nfd_common.h
@@ -165,9 +165,28 @@
 #define NFD_VNIC_TYPE_CTRL  2
 
 #define NFD_TOTAL_VFQS      (NFD_MAX_VFS * NFD_MAX_VF_QUEUES)
 #define NFD_TOTAL_CTRLQS    (NFD_MAX_CTRL * NFD_MAX_CTRL_QUEUES)
-#define NFD_TOTAL_PFQS      (NFD_MAX_PFS * NFD_MAX_PF_QUEUES)
+#ifdef NFD_USE_OVERSUBSCRIPTION
+    #define NFD_OVERSUBSCRIBED (NFD_TOTAL_VFQS + NFD_TOTAL_CTRLQS + \
+                                NFD_MAX_PFS * NFD_MAX_PF_QUEUES - 64)
+    #if (NFD_OVERSUBSCRIBED < 0)
+        #undef NFD_OVERSUBSCRIBED
+        #define NFD_OVERSUBSCRIBED 0
+    #endif
+
+    #if ((NFD_OVERSUBSCRIBED != 0) &&               \
+         (NFD_OVERSUBSCRIBED >= NFD_MAX_PF_QUEUES))
+        #error "Insufficient queues on PF for requested oversubscription"
+    #endif
+
+    #define NFD_LAST_PF_MAX_QUEUES (NFD_MAX_PF_QUEUES - NFD_OVERSUBSCRIBED)
+    #define NFD_TOTAL_PFQS                                  \
+        (NFD_MAX_PFS * NFD_MAX_PF_QUEUES - NFD_OVERSUBSCRIBED)
+
+#else
+    #define NFD_TOTAL_PFQS      (NFD_MAX_PFS * NFD_MAX_PF_QUEUES)
+#endif
 
 #if (NFD_TOTAL_VFQS + NFD_TOTAL_CTRLQS + NFD_TOTAL_PFQS > 64)
 #error "Total number of NFD queues per island cannot exceed 64"
 #endif
diff --git a/me/blocks/vnic/pci_in_me0.c b/me/blocks/vnic/pci_in_me0.c
--- a/me/blocks/vnic/pci_in_me0.c
+++ b/me/blocks/vnic/pci_in_me0.c
@@ -67,11 +67,8 @@ main(void)
     __shared __gpr unsigned int status = 0;
 
     /* Perform per ME initialisation  */
     if (ctx() == 0) {
-        ctassert((NFD_MAX_VFS * NFD_MAX_VF_QUEUES +
-                  NFD_MAX_PFS * NFD_MAX_PF_QUEUES) <= 64);
-
         nfd_cfg_check_pcie_link(); /* Will halt ME on failure */
 
         /* Initialisation that does not swap */
         nfd_cfg_init_cfg_msg(&nfd_cfg_sig_pci_in, &cfg_msg);
diff --git a/me/blocks/vnic/pci_out_sb.uc b/me/blocks/vnic/pci_out_sb.uc
--- a/me/blocks/vnic/pci_out_sb.uc
+++ b/me/blocks/vnic/pci_out_sb.uc
@@ -290,8 +290,13 @@
 
     #if ((NFD_MAX_VFS != 0) && (NFD_MAX_PFS != 0) && defined(NFD_USE_CTRL))
         .if (NFD_VID_IS_PF(in_vid))
             move(maxqs, NFD_MAX_PF_QUEUES)
+            #ifdef NFD_USE_OVERSUBSCRIPTION
+                .if (in_vid == NFD_LAST_PF)
+                    move(maxqs, NFD_LAST_PF_MAX_QUEUES)
+                .endif
+            #endif
             immed[rid, 0]
         .elif (NFD_VID_IS_VF(in_vid))
             move(maxqs, NFD_MAX_VF_QUEUES)
             alu[rid, in_vid, +, NFD_CFG_VF_OFFSET]
@@ -301,23 +306,38 @@
         .endif
     #elif ((NFD_MAX_PFS != 0) && defined(NFD_USE_CTRL))
         .if (NFD_VID_IS_PF(in_vid))
             move(maxqs, NFD_MAX_PF_QUEUES)
+            #ifdef NFD_USE_OVERSUBSCRIPTION
+                .if (in_vid == NFD_LAST_PF)
+                    move(maxqs, NFD_LAST_PF_MAX_QUEUES)
+                .endif
+            #endif
             immed[rid, 0]
         .else
             move(maxqs, NFD_MAX_CTRL_QUEUES)
             immed[rid, 0]
         .endif
     #elif ((NFD_MAX_VFS != 0) && (NFD_MAX_PFS != 0))
         .if (NFD_VID_IS_PF(in_vid))
             move(maxqs, NFD_MAX_PF_QUEUES)
+            #ifdef NFD_USE_OVERSUBSCRIPTION
+                .if (in_vid == NFD_LAST_PF)
+                    move(maxqs, NFD_LAST_PF_MAX_QUEUES)
+                .endif
+            #endif
             immed[rid, 0]
         .else
             move(maxqs, NFD_MAX_VF_QUEUES)
             alu[rid, in_vid, +, NFD_CFG_VF_OFFSET]
         .endif
     #elif (NFD_MAX_PFS != 0)
         move(maxqs, NFD_MAX_PF_QUEUES)
+        #ifdef NFD_USE_OVERSUBSCRIPTION
+            .if (in_vid == NFD_LAST_PF)
+                move(maxqs, NFD_LAST_PF_MAX_QUEUES)
+            .endif
+        #endif
         immed[rid, 0]
     #elif (NFD_MAX_VFS != 0)
         move(maxqs, NFD_MAX_VF_QUEUES)
         alu[rid, in_vid, +, NFD_CFG_VF_OFFSET]
diff --git a/me/blocks/vnic/shared/nfd_cfg_internal.c b/me/blocks/vnic/shared/nfd_cfg_internal.c
--- a/me/blocks/vnic/shared/nfd_cfg_internal.c
+++ b/me/blocks/vnic/shared/nfd_cfg_internal.c
@@ -574,8 +574,18 @@ static void
           NFD_BPF_START_OFF | NFD_BPF_DONE_OFF << 16,
           30 << 8 /* CTM buf size / 64 */ };
 #endif
 
+#ifdef NFD_USE_OVERSUBSCRIPTION
+    /* Adjust the number of queues advertised to the host
+     * for the last PF */
+    if (vid == NFD_LAST_PF) {
+        cfg[(NFP_NET_CFG_MAX_TXRINGS - NFP_NET_CFG_VERSION) / 4] =
+            NFD_LAST_PF_MAX_QUEUES;
+        cfg[(NFP_NET_CFG_MAX_RXRINGS - NFP_NET_CFG_VERSION) / 4] =
+            NFD_LAST_PF_MAX_QUEUES;
+    }
+#endif
     mem_write64(&cfg, NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_VERSION,
                 sizeof cfg);
 
     mem_write8(&exn_lsc, NFD_CFG_BAR_ISL(PCIE_ISL, vid) + NFP_NET_CFG_LSC,
@@ -954,8 +964,13 @@ nfd_cfg_next_flr(struct nfd_cfg_msg *cfg
                 vid = NFD_FIRST_PF;
 #endif
             }
 
+#ifdef NFD_USE_OVERSUBSCRIPTION
+            if (vid == NFD_LAST_PF)
+                cfg_msg->queue = NFD_LAST_PF_MAX_QUEUES - 1;
+#endif
+
             /* Setup the remaining parse_msg info */
             cfg_msg->vid = vid;
             cfg_msg->interested = 1;
             cfg_msg->msg_valid = 1;
@@ -1121,8 +1136,13 @@ nfd_cfg_parse_msg(struct nfd_cfg_msg *cf
 
     /* Set the queue to process to the final queue */
     if (NFD_VID_IS_PF(cfg_msg->vid)) {
         cfg_msg->queue = NFD_MAX_PF_QUEUES - 1;
+#ifdef NFD_USE_OVERSUBSCRIPTION
+        if (cfg_msg->vid == NFD_LAST_PF) {
+            cfg_msg->queue = NFD_LAST_PF_MAX_QUEUES - 1;
+        }
+#endif
     } else if (NFD_VID_IS_CTRL(cfg_msg->vid)) {
         cfg_msg->queue = NFD_MAX_CTRL_QUEUES - 1;
     } else {
         cfg_msg->queue = NFD_MAX_VF_QUEUES - 1;
diff --git a/me/blocks/vnic/shared/nfd_flr.c b/me/blocks/vnic/shared/nfd_flr.c
--- a/me/blocks/vnic/shared/nfd_flr.c
+++ b/me/blocks/vnic/shared/nfd_flr.c
@@ -192,8 +192,18 @@ nfd_flr_init_pf_cfg_bar(__emem char *isl
           NFD_BPF_START_OFF | NFD_BPF_DONE_OFF << 16,
           30 << 8 /* CTM buf size / 64 */ };
 #endif
 
+#ifdef NFD_USE_OVERSUBSCRIPTION
+    /* Adjust the number of queues advertised to the host
+     * for the last PF */
+    if (vid == NFD_LAST_PF) {
+        cfg[(NFP_NET_CFG_MAX_TXRINGS - NFP_NET_CFG_VERSION) / 4] =
+            NFD_LAST_PF_MAX_QUEUES;
+        cfg[(NFP_NET_CFG_MAX_RXRINGS - NFP_NET_CFG_VERSION) / 4] =
+            NFD_LAST_PF_MAX_QUEUES;
+    }
+#endif
     mem_write64(&cfg,
                 NFD_CFG_BAR(isl_base, vid) + NFP_NET_CFG_VERSION,
                 sizeof cfg);
 
diff --git a/me/blocks/vnic/svc/msix_qmon.c b/me/blocks/vnic/svc/msix_qmon.c
--- a/me/blocks/vnic/svc/msix_qmon.c
+++ b/me/blocks/vnic/svc/msix_qmon.c
@@ -81,8 +81,11 @@
  */
 #define MSIX_RINGS_MASK(num_rings)  ((num_rings) == 64 ? 0xffffffffffffffff : \
                                      (1ull << (num_rings)) - 1)
 #define MSIX_PF_RINGS_MASK          MSIX_RINGS_MASK(NFD_MAX_PF_QUEUES)
+#ifdef NFD_USE_OVERSUBSCRIPTION
+#define MSIX_LAST_PF_RINGS_MASK     MSIX_RINGS_MASK(NFD_LAST_PF_MAX_QUEUES)
+#endif
 #define MSIX_VF_RINGS_MASK          MSIX_RINGS_MASK(NFD_MAX_VF_QUEUES)
 #define MSIX_CTRL_RINGS_MASK        MSIX_RINGS_MASK(NFD_MAX_CTRL_QUEUES)
 
 
@@ -281,14 +284,19 @@ msix_reconfig_rings(unsigned int pcie_is
         msix_cls_tx_new_enabled[pcie_isl] = new_queues_en;
     }
 
     /* Update the enabled bit mask with queues for this VF. */
-    if (NFD_VID_IS_PF(vid))
+    if (NFD_VID_IS_PF(vid)) {
         vf_queue_mask = MSIX_PF_RINGS_MASK << NFD_VID2NATQ(vid, 0);
-    else if (NFD_VID_IS_CTRL(vid))
+#ifdef NFD_USE_OVERSUBSCRIPTION
+        if (vid == NFD_LAST_PF)
+            vf_queue_mask = MSIX_LAST_PF_RINGS_MASK << NFD_VID2NATQ(vid, 0);
+#endif
+    } else if (NFD_VID_IS_CTRL(vid)) {
         vf_queue_mask = MSIX_CTRL_RINGS_MASK << NFD_VID2NATQ(vid, 0);
-    else
+    } else {
         vf_queue_mask = MSIX_VF_RINGS_MASK << NFD_VID2NATQ(vid, 0);
+    }
 
     if (rx_rings) {
         msix_cls_rx_enabled[pcie_isl] &= ~vf_queue_mask;
         msix_cls_rx_enabled[pcie_isl] |= queues;
@@ -405,10 +413,20 @@ msix_qmon_reconfig(unsigned int pcie_isl
         }
 
         /* Make sure the vnic is not configuring rings it has no control over */
         if (NFD_VID_IS_PF(vid)) {
+#ifdef NFD_USE_OVERSUBSCRIPTION
+            if (vid != NFD_LAST_PF) {
+                vf_tx_rings_new &= MSIX_PF_RINGS_MASK;
+                vf_rx_rings_new &= MSIX_PF_RINGS_MASK;
+            } else {
+                vf_tx_rings_new &= MSIX_LAST_PF_RINGS_MASK;
+                vf_rx_rings_new &= MSIX_LAST_PF_RINGS_MASK;
+            }
+#else
             vf_tx_rings_new &= MSIX_PF_RINGS_MASK;
             vf_rx_rings_new &= MSIX_PF_RINGS_MASK;
+#endif
         } else if (NFD_VID_IS_CTRL(vid)) {
             vf_tx_rings_new &= MSIX_CTRL_RINGS_MASK;
             vf_rx_rings_new &= MSIX_CTRL_RINGS_MASK;
         } else {
