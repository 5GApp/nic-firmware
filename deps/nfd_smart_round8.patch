# HG changeset patch
# User Michael Rapson <michael.rapson@netronome.com>
# Date 1506566465 -7200
# Branch abi-3.0
# Node ID 04c46722baada8a2de2ba11e050f57603af1a177
# Parent  da20103fce9671d28aea8c7f0c15748dd4859eec
[TESTING] Round up DMA length if it won't cause the DMA to cross an 8B addr
* Packets smaller than 136B short circuit the rounding.
* Rounding not implmented for LSO or gather packets.  It is questionable
  whether they would get a significant performance advantage.

diff --git a/me/blocks/vnic/pci_in/issue_dma.c b/me/blocks/vnic/pci_in/issue_dma.c
--- a/me/blocks/vnic/pci_in/issue_dma.c
+++ b/me/blocks/vnic/pci_in/issue_dma.c
@@ -1551,8 +1551,33 @@ do {                                    
             /* partial batches. */                                      \
             __critical_path(_priority);                                 \
         }                                                               \
                                                                         \
+        /* TEMP do smart rounding of the DMA length, if the packet */   \
+        /* is large enough to justify it */                             \
+        if (dma_len > (128 + 8 - 1)) {                                  \
+            unsigned int start_off;                                     \
+            unsigned int len_adj;                                       \
+                                                                        \
+            /* dma_len stores "length - 1" */                           \
+            /* round8(v) = 1 + (v - 1) + 7 - ((v - 1) & 7) */           \
+            /* hence round_dma(dma_len) = dma_len + 7 - dma_len & 7 */  \
+            /* it is safe to round dma_len if: */                       \
+            /* 1: start_off == 0; rounding up can't cross an 8B boundary */ \
+            /* 2: sign(start_off + length & 7 - 8) == */                \
+            /*       sign(start_off + 8 - 8) == "+ve" */                \
+            /* Hence start_off > (8 - length & 7) */                    \
+            /* or start_off > len_adj */                                \
+            len_adj = 7 - (dma_len & 7);                                \
+            start_off = pcie_addr_lo & 7;                               \
+            if ((start_off == 0) || (start_off > len_adj)) {            \
+                /* XXX inspecting the list file, it's better to test */ \
+                /* start_off == 0 first so that the len_adj calc */     \
+                /* can be done in the defer shadow */                   \
+                dma_len += len_adj;                                     \
+            }                                                           \
+        }                                                               \
+                                                                        \
         /* Issue final DMA for the packet */                            \
         dma_out.pkt##_pkt##.__raw[0] = cpp_addr_lo + NFD_IN_DATA_OFFSET; \
         dma_out.pkt##_pkt##.__raw[2] = pcie_addr_lo;                    \
         dma_out.pkt##_pkt##.__raw[3] = (pcie_hi_word |                  \
